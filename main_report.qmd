---
title: "Depth of coverage"
author: "A.G."
format: 
 html:
   self-contained: true
   theme: "cosmo"
   toc: true
   toc-location: left
editor: source
params:
  input_files: "config/input_files_v2.csv"
  gene_chunk_size: 20
  run_ids: "data/twist_myelom_run_IDs.tsv"
---

```{r}
#| label: set-env
#| include: false
Sys.setenv(CONFIG = params$input_files)
```

```{bash}
#| label: bedtools
#| eval: true
#| message: false
#| warning: false
#| cache: true
#| include: false

# Function to extract path from config CSV
get_path() {
    awk -F',' -v target="$1" '$1 == target {print $2}' "$CONFIG"
}

MANE_GTF=$(get_path "mane_gtf")
MANE_EXONS_ONLY=$(get_path "mane_exons")
PROBES=$(get_path "probes")
ANNOTATED_PROBES=$(get_path "probes_annotated")

# Extract MANE exons
grep "\texon\t" "$MANE_GTF" > "$MANE_EXONS_ONLY"

# Intersect them with targets covered by probes (120bp)
pixi run bedtools intersect -a "$PROBES" -b "$MANE_EXONS_ONLY" -wao > "$ANNOTATED_PROBES"

```




```{r}
#| label: load input files
#| echo: false
#| cache: true
#| include: false

library(readr)

input_files <- params$input_files |>
  read_csv(show_col_types = F)

run_ids_table <- params$run_ids |>
  read_tsv(show_col_types = F)

path_dict <- setNames(input_files$path, input_files$name)
```


```{r}
#| label: libraries & functions
#| echo: false
#| cache: false
#| message: false
#| warning: false


library(tidyr)
library(dplyr)
library(ggplot2)
library(purrr)
library(DT)
library(plotly)
library(stringr)
library(tibble)


annotation2tibble <- function(column) {
  # transform the targets
  # turn column with annotations (X13) into tibble
  # column: vector of character strings
  
  # extract gene name
  gene_name <- str_extract(column, 'gene_name "([^"]+)";') |>
    str_remove('gene_name "') |>
    str_remove('";')
  # extract exon number
  exon_number <- as.integer(
    str_extract(column, 'exon_number ([^"]+);') |>
      str_remove('exon_number ') |>
      str_remove(';')
  )
  # extract transcript name
  transcript_name <- str_extract(column, 'transcript_name "([^"]+)";') |>
    str_remove('transcript_name "') |>
    str_remove('";')
  # extract refseq
  refseq <- str_extract(column, 'db_xref "([^"]+)";') |>
    str_remove('db_xref "') |>
    str_remove('";') |>
    str_remove("RefSeq:")
  
  output <- tibble(
    "gene_name" = gene_name,
    "exon_number" = exon_number,
    "transcript_name" = transcript_name,
    "refseq" = refseq
  )
  
  return(output)
}


read_bed <- function(filename) {
  # read a BED file
  # filename: name of a BED file
  
  # extract sample name first
  # replace underscores
  sample_name <- basename(filename) |>
    str_remove("\\.regions\\.bed\\.gz$")

  # read bed file and add the sample name
  bed <- read_tsv(filename, col_names = F, show_col_types = F) |>
    mutate("sample" = sample_name)
  if (nrow(bed) == 0) {
    print(paste0("empty file ", filename))
  }
  
  return(bed)
}


make_gene_plot <- function(gene, bed = bed_annotated) {
  # gene: gene name (character string)
  # bed: bed file object (data frame/tibble)
  
  bed_gene <- bed |> dplyr::filter(gene_name == gene)
  
  fig <- plot_ly(
    data = bed_gene,
    y = ~ X5,
    x = ~ label,
    type = "box",
    boxpoints = "all",
    jitter = 0.3,
    pointpos = 0,
    marker = list(size = 4, opacity = 0.6),
    line = list(color = 'rgba(0,0,0,0.5)'),
    fillcolor = 'transparent',
    text = ~ sample
  ) |>
    layout(
      title = paste0(gene, " median depth of coverage"),
      yaxis = list(title = "depth"),
      xaxis = list(title = "target region")
    )
  
  return(fig)
}


make_sample_plot <- function(bed,
                             group_by_gene = FALSE,
                             gene = "") {
  # bed: bed file object (data frame/tibble)
  # group_by_gene: group by gene or not (logical)
  # gene: gene to make plot for (character string, only if group_by_gene=TRUE)
  if (!group_by_gene) {
    plot_ly(
      data = bed,
      y = ~ X5,
      x = ~ sample,
      type = "box",
      boxpoints = "all",
      jitter = 0.3,
      pointpos = 0,
      marker = list(
        size = 4,
        opacity = 0.6,
        color = 'rgba(102,0,0,0.5)'
      ),
      line = list(color = 'rgba(102,0,0,0.5)'),
      fillcolor = 'transparent',
      text = ~ label
    ) |>
      layout(
        title = "Median depth of coverage",
        yaxis = list(title = "depth"),
        xaxis = list(title = "sample")
      )
  } else {
    plot_ly(
      data = dplyr::filter(bed, gene_name == gene),
      y = ~ X5,
      x = ~ sample,
      type = "box",
      boxpoints = "all",
      jitter = 0.3,
      pointpos = 0,
      marker = list(
        size = 4,
        opacity = 0.6,
        color = 'rgba(102,0,0,0.5)'
      ),
      line = list(color = 'rgba(102,0,0,0.5)'),
      fillcolor = 'transparent',
      text = ~ label
    ) |>
      layout(
        title = paste0(gene, " median depth of coverage"),
        yaxis = list(title = "depth"),
        xaxis = list(title = "sample")
      )
  }
  
}


plot_backbone <- function(chromosome, bed = bed_annotated_backbone) {
  # chromosome: chromosome name (character sting: chr1 or ch17)
  # bed: bed object with backbone targets (data frame)
  chr_bed <- bed |>
    filter(grepl(str_glue("^{chromosome}_"), X4))
  
  fig <- plot_ly(
    data = chr_bed,
    y = ~ X5,
    x = ~ sample,
    type = "box",
    boxpoints = "all",
    jitter = 0.3,
    pointpos = 0,
    marker = list(
      size = 4,
      opacity = 0.6,
      color = 'rgba(102,0,0,0.5)'
    ),
    line = list(color = 'rgba(102,0,0,0.5)'),
    fillcolor = 'transparent',
    text = ~ label
  ) |>
    layout(
      title = paste0(chromosome, " median depth of coverage"),
      yaxis = list(title = "depth"),
      xaxis = list(title = "sample")
    )
  
  return(fig)
}


make_cov_table <- function(bed, by_gene = FALSE) {
  # bed: data frame object representing BED file
  if (by_gene) {
    bed |>
      group_by(gene_name, label) |>
      summarise(
        median_coverage = round(median(X5), 0),
        min_coverage = round(min(X5), 0),
        max_coverage = round(max(X5), 0)
      )
  } else {
    bed |>
      group_by(sample) |>
      summarise(
        median_coverage = round(median(X5), 0),
        min_coverage = round(min(X5), 0),
        max_coverage = round(max(X5), 0)
      )
  }
  
}

```


```{r}
#| label: computations
#| echo: false
#| cache: false
#| message: false
#| warning: false

library(readr)
# read bed files with coverage from mosdepth tool
dir_with_depth <- path_dict["mosdepth_dir"]
annotated_targets_bed <- path_dict["probes_annotated"]

files_found_full_paths <- list.files(
  path = dir_with_depth,
  pattern = paste0("\\", ".regions.bed.gz", "$"),
  full.names = TRUE,
  ignore.case = TRUE
)


bed_joined <- map_dfr(files_found_full_paths, ~ read_bed(.))

# get names of the target regions
targets <- unique(bed_joined$X4)

# targets without the backbone regions
targets_no_bb <- targets[!(grepl("^Backbone_", targets))]

targets_bb <- setdiff(targets, targets_no_bb)

# get names of the samples
samples <- unique(bed_joined$sample)

# read the annotated targets: their position relative to known genes, their exons and transcripts
# NB: many targets belong to different genes, hence the inflated output
targets_annotated <- read_tsv(
  annotated_targets_bed,
  col_names = F,
  show_col_types = F
) |>
  select(X1, X2, X3, X4, X13)


# table with parsed gene names and exon numbers
# but some genes may have come from the backbone
# they should be removed
gene_exon <- annotation2tibble(targets_annotated$X13)

# get gene names
genes <- unique(gene_exon$gene_name)[!is.na(unique(gene_exon$gene_name))]

# some genes represented only once
# these are the backbone
single_genes <- gene_exon |>
  group_by(gene_name) |>
  count() |>
  filter(n == 1) |>
  pull("gene_name")

# add gene names and exon numbers to annotated targets
targets_annotated_parsed <-
  targets_annotated |>
  select(-X13) |>
  bind_cols(gene_exon) |>
  #unite("gene_exon", gene_name:exon_number, sep="_", remove=FALSE, na.rm=TRUE) |>
  select(-c(X1, X2, X3))

# this should be empty:
# targets_annotated_parsed %>% filter(grepl("^NM_*", X4)) %>% filter(is.na(gene_name))

# join bed with coverage and annotation of the targets
# this one contains genes with targets and genes sitting NOT in the backbone
bed_annotated <- left_join(bed_joined, targets_annotated_parsed, by = "X4") |>
  distinct() |>
  filter(!is.na(gene_name), X4 %in% targets_no_bb) |>
  unite(
    col = "label",
    gene_name,
    exon_number,
    refseq,
    sep = ":",
    remove = F
  )

# this one contains targets sitting IN the backbone
bed_annotated_backbone <- left_join(bed_joined, targets_annotated_parsed, by =
                                      "X4") |>
  distinct() |>
  filter(X4 %in% targets_bb) |>
  unite(
    col = "label",
    gene_name,
    exon_number,
    refseq,
    sep = ":",
    remove = F
  )

genes_no_bb <- str_sort(unique(bed_annotated$gene_name))
```


# Grouped by genes


```{r}
#| label: dynamic-gene-plots
#| results: asis
#| echo: false

chunk_size <- params$gene_chunk_size
num_genes <- length(genes_no_bb)

if (num_genes > 0) {
  chunks <- split(1:num_genes, ceiling(seq_along(1:num_genes) / chunk_size))
  
  for (chunk in chunks) {
    start_idx <- min(chunk)
    end_idx <- max(chunk)
    
    # Print the range header
    cat(sprintf("\n## %s - %s\n\n", genes_no_bb[start_idx], genes_no_bb[end_idx]))
    
    # Start the tabset div
    cat("::: {#plot-tabs .panel-tabset}\n\n")
    
    for (i in chunk) {
      res <- knitr::knit_child("_make_gene_boxplot.qmd", quiet = TRUE)
      cat(res, sep = "\n")
    }
    
    # End the tabset div
    cat("\n:::\n")
  }
} else {
  cat("\n## No genes found\n\nNo genes were identified for plotting.\n")
}
```


## IGH fusion genes

::: {#plot-tabs .panel-tabset}

```{r}
#| label: fusion genes
#| results: asis
#| echo: false
fusion_genes <- c("FGFR3", "CCND3", "CCND1", "MAF", "MAFB")
fusion_index <- match(fusion_genes, genes_no_bb)
fusion_index <- fusion_index[!is.na(fusion_index)]

if (length(fusion_index) == 0) {
  cat("\nNo fusion genes found in dataset.\n")
} else {
  for(i in fusion_index) {
    res <- knitr::knit_child("_make_gene_boxplot.qmd", quiet = TRUE)
    cat(res, sep = "\n")
  }
}
```

:::


## Table

```{r}
#| label: print table1
#| eval: true
#| message: false
#| warning: false
#| echo: false

med_cov_gene <- make_cov_table(bed_annotated, by_gene = TRUE) |>
  dplyr::rename("gene" = gene_name, "gene:exon:refseq" = label)

DT::datatable(med_cov_gene, options = list(pageLength = 10, lengthMenu = c(5, 10, 15, 20)))
```


# Grouped by samples

## Targets

```{r}
#| label: targets by sample
#| echo: false
#| fig-width: 20
#| fig-height: 20

make_sample_plot(bed_annotated, group_by_gene = FALSE)
```


## IGH fusion genes

::: {#plot-tabs .panel-tabset}

```{r}
#| label: fusion genes2
#| results: asis
#| echo: false
#| fig-width: 20
#| fig-height: 20

fusion_index <- match(fusion_genes, genes_no_bb)
fusion_index <- fusion_index[!is.na(fusion_index)]

if (length(fusion_index) == 0) {
  cat("\nNo fusion genes found in dataset.\n")
} else {
  for(i in fusion_index) {
    res <- knitr::knit_child("_make_gene_boxplot.qmd", quiet = TRUE)
    cat(res, sep = "\n")
  }
}

```

:::

### Table

```{r}
#| label: print table2
#| message: false
#| warning: false
#| echo: false

med_cov_samples <- make_cov_table(bed_annotated)

DT::datatable(med_cov_samples, options = list(pageLength = 10, lengthMenu = c(5, 10, 15, 20)))
```


## Backbone

::: {#plot-tabs .panel-tabset}

### Chr1

```{r}
#| label: backbone chr1
#| echo: false
#| cache: false
#| message: false
#| warning: false
#| fig-width: 20
#| fig-height: 20

plot_backbone("Backbone_Chr1")
```


### Chr17

```{r}
#| label: backbone chr17
#| echo: false
#| cache: false
#| message: false
#| warning: false
#| fig-width: 20
#| fig-height: 20

plot_backbone("Backbone_Chr17")
```

:::

### Table

```{r}
#| label: print table
#| echo: false
#| message: false
#| warning: false

med_cov_chroms <- make_cov_table(bed_annotated_backbone)

DT::datatable(med_cov_chroms, options = list(pageLength = 10, lengthMenu = c(5, 10, 15, 20)))
```

# Grouped by sequencing runs

```{r}
#| label: sequencing runs
#| echo: false
#| message: false
#| warning: false

# read run IDs table
run_ids_table <- run_ids_table |>
  mutate(
    run_ID = str_replace(run_ID, "^M", "Twist M"),
    run_ID = str_replace_all(run_ID, " ", "-")
  )
  
# unify values in the run_ID column


bed_annotated_runID <- left_join(bed_annotated, run_ids_table, by="sample") |>
  select(X5, run_ID, sample, transcript_name, refseq)

plot_ly(
  data = bed_annotated_runID,
  y = ~ X5,
  x = ~ run_ID,
  type = "box",
  line = list(color = 'rgba(0,0,0,0.5)'),
  text = ~ sample
) |>
  layout(
    title = "Median depth of coverage per run",
    yaxis = list(title = "depth"),
    xaxis = list(title = "")
  )
```

  )
```

