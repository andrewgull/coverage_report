---
title: "Depth of coverage"
author: "A.G."
format: 
 html:
   self-contained: true
   theme: "cosmo"
   toc: true
   toc-location: left
editor: source
params:
  input_files: "config/input_files_v2.csv"
  gene_chunk_size: 20
  run_ids: "data/twist_myelom_run_IDs.tsv"
---

```{r}
#| label: set-env
#| include: false
Sys.setenv(CONFIG = params$input_files)
```

```{bash}
#| label: bedtools
#| eval: true
#| message: false
#| warning: false
#| cache: false
#| include: false

# Function to extract path from config CSV
get_path() {
    awk -F',' -v target="$1" '$1 == target {print $2}' "$CONFIG"
}

MANE_GTF=$(get_path "mane_gtf")
MANE_EXONS_ONLY=$(get_path "mane_exons")
PROBES=$(get_path "probes")
ANNOTATED_PROBES=$(get_path "probes_annotated")

# Extract MANE exons
grep "\texon\t" "$MANE_GTF" > "$MANE_EXONS_ONLY"

# Intersect them with targets covered by probes (120bp)
pixi run bedtools intersect -a "$PROBES" -b "$MANE_EXONS_ONLY" -wao > "$ANNOTATED_PROBES"

```




```{r}
#| label: setup
#| echo: false
#| cache: false
#| include: false

library(here)
source(here("R", "functions.R"))

input_files <- params$input_files |>
  read_csv(show_col_types = F)

run_ids_table <- params$run_ids |>
  read_tsv(show_col_types = F)

path_dict <- setNames(input_files$path, input_files$name)

```


```{r}
#| label: computations
#| echo: false
#| cache: false
#| message: false
#| warning: false

library(readr)
# read bed files with coverage from mosdepth tool
dir_with_depth <- path_dict["mosdepth_dir"]
annotated_targets_bed <- path_dict["probes_annotated"]

files_found_full_paths <- list.files(
  path = dir_with_depth,
  pattern = paste0("\\", ".regions.bed.gz", "$"),
  full.names = TRUE,
  ignore.case = TRUE
)


bed_joined <- map_dfr(files_found_full_paths, ~ read_bed(.))

# get names of the target regions
targets <- unique(bed_joined$X4)

# targets without the backbone regions
targets_no_bb <- targets[!(grepl("^Backbone_", targets))]

targets_bb <- setdiff(targets, targets_no_bb)

# get names of the samples
samples <- unique(bed_joined$sample)

# read the annotated targets: their position relative to known genes, their exons and transcripts
# NB: many targets belong to different genes, hence the inflated output
targets_annotated <- read_tsv(
  annotated_targets_bed,
  col_names = F,
  show_col_types = F
) |>
  select(X1, X2, X3, X4, X13)


# table with parsed gene names and exon numbers
# but some genes may have come from the backbone
# they should be removed
gene_exon <- annotation2tibble(targets_annotated$X13)

# get gene names
genes <- unique(gene_exon$gene_name)[!is.na(unique(gene_exon$gene_name))]

# some genes represented only once
# these are the backbone
single_genes <- gene_exon |>
  group_by(gene_name) |>
  count() |>
  filter(n == 1) |>
  pull("gene_name")

# add gene names and exon numbers to annotated targets
targets_annotated_parsed <-
  targets_annotated |>
  select(-X13) |>
  bind_cols(gene_exon) |>
  #unite("gene_exon", gene_name:exon_number, sep="_", remove=FALSE, na.rm=TRUE) |>
  select(-c(X1, X2, X3))

# this should be empty:
# targets_annotated_parsed %>% filter(grepl("^NM_*", X4)) %>% filter(is.na(gene_name))

# join bed with coverage and annotation of the targets
# this one contains genes with targets and genes sitting NOT in the backbone
bed_annotated <- left_join(bed_joined, targets_annotated_parsed, by = "X4") |>
  distinct() |>
  filter(!is.na(gene_name), X4 %in% targets_no_bb) |>
  unite(
    col = "label",
    gene_name,
    exon_number,
    refseq,
    sep = ":",
    remove = F
  )

# this one contains targets sitting IN the backbone
bed_annotated_backbone <- left_join(bed_joined, targets_annotated_parsed, by =
                                      "X4") |>
  distinct() |>
  filter(X4 %in% targets_bb) |>
  unite(
    col = "label",
    gene_name,
    exon_number,
    refseq,
    sep = ":",
    remove = F
  )

genes_no_bb <- str_sort(unique(bed_annotated$gene_name))
```


# Grouped by genes


```{r}
#| label: dynamic-gene-plots
#| results: asis
#| echo: false

chunk_size <- params$gene_chunk_size
num_genes <- length(genes_no_bb)

if (num_genes > 0) {
  chunks <- split(1:num_genes, ceiling(seq_along(1:num_genes) / chunk_size))
  
  for (chunk in chunks) {
    start_idx <- min(chunk)
    end_idx <- max(chunk)
    
    # Print the range header
    cat(sprintf("\n## %s - %s\n\n", genes_no_bb[start_idx], genes_no_bb[end_idx]))
    
    # Start the tabset div
    cat("::: {#plot-tabs .panel-tabset}\n\n")
    
    for (i in chunk) {
      res <- knitr::knit_child("includes/_make_gene_boxplot.qmd", quiet = TRUE)
      cat(res, sep = "\n")
    }
    
    # End the tabset div
    cat("\n:::\n")
  }
} else {
  cat("\n## No genes found\n\nNo genes were identified for plotting.\n")
}
```


## IGH fusion genes

::: {#plot-tabs .panel-tabset}

```{r}
#| label: fusion genes
#| results: asis
#| echo: false

fusion_genes <- c("FGFR3", "CCND3", "CCND1", "MAF", "MAFB")
fusion_index <- match(fusion_genes, genes_no_bb)
fusion_index <- fusion_index[!is.na(fusion_index)]

if (length(fusion_index) == 0) {
  cat("\nNo fusion genes found in dataset.\n")
} else {
  for(i in fusion_index) {
    res <- knitr::knit_child("includes/_make_gene_boxplot.qmd", quiet = TRUE)
    cat(res, sep = "\n")
  }
}
```

:::


## Table

```{r}
#| label: print table1
#| eval: true
#| message: false
#| warning: false
#| echo: false

med_cov_gene <- make_cov_table(bed_annotated, by_gene = TRUE) |>
  dplyr::rename("gene" = gene_name, "gene:exon:refseq" = label)

DT::datatable(med_cov_gene, options = list(pageLength = 10, lengthMenu = c(5, 10, 15, 20)))
```


# Grouped by samples

## Targets

```{r}
#| label: targets by sample
#| echo: false
#| fig-width: 20
#| fig-height: 20

make_sample_plot(bed_annotated, group_by_gene = FALSE)
```


## IGH fusion genes

::: {#plot-tabs .panel-tabset}

```{r}
#| label: fusion genes2
#| results: asis
#| echo: false
#| fig-width: 20
#| fig-height: 20

fusion_index <- match(fusion_genes, genes_no_bb)
fusion_index <- fusion_index[!is.na(fusion_index)]

if (length(fusion_index) == 0) {
  cat("\nNo fusion genes found in dataset.\n")
} else {
  for(i in fusion_index) {
    res <- knitr::knit_child("includes/_make_gene_boxplot.qmd", quiet = TRUE)
    cat(res, sep = "\n")
  }
}

```

:::

### Table

```{r}
#| label: print table2
#| message: false
#| warning: false
#| echo: false

med_cov_samples <- make_cov_table(bed_annotated)

DT::datatable(med_cov_samples, options = list(pageLength = 10, lengthMenu = c(5, 10, 15, 20)))
```


## Backbone

::: {#plot-tabs .panel-tabset}

### Chr1

```{r}
#| label: backbone chr1
#| echo: false
#| cache: false
#| message: false
#| warning: false
#| fig-width: 20
#| fig-height: 20

plot_backbone("Backbone_Chr1")
```


### Chr17

```{r}
#| label: backbone chr17
#| echo: false
#| cache: false
#| message: false
#| warning: false
#| fig-width: 20
#| fig-height: 20

plot_backbone("Backbone_Chr17")
```

:::

### Table

```{r}
#| label: print table
#| echo: false
#| message: false
#| warning: false

med_cov_chroms <- make_cov_table(bed_annotated_backbone)

DT::datatable(med_cov_chroms, options = list(pageLength = 10, lengthMenu = c(5, 10, 15, 20)))
```

# Grouped by sequencing runs

```{r}
#| label: sequencing runs
#| echo: false
#| message: false
#| warning: false

# read run IDs table
run_ids_table <- run_ids_table |>
  mutate(
    run_ID = str_replace(run_ID, "^M", "Twist M"),
    run_ID = str_replace_all(run_ID, " ", "-")
  )
  
# unify values in the run_ID column


bed_annotated_runID <- left_join(bed_annotated, run_ids_table, by="sample") |>
  select(X5, run_ID, sample, transcript_name, refseq)

plot_ly(
  data = bed_annotated_runID,
  y = ~ X5,
  x = ~ run_ID,
  type = "box",
  line = list(color = 'rgba(0,0,0,0.5)'),
  text = ~ sample
) |>
  layout(
    title = "Median depth of coverage per run",
    yaxis = list(title = "depth"),
    xaxis = list(title = "")
  )
```
